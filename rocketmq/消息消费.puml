@startuml
DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:客户端start启动
DefaultMQPushConsumerImpl -> MQClientInstance:rebalanceImmediately立刻rebalance
MQClientInstance -> MQClientInstance:遍历consumerTable，调用每个group的DefaultMQPushConsumer.RebalanceImpl.dobalance
MQClientInstance -> DefaultMQPushConsumer.RebalanceImpl: 对DefaultMQPushConsumer 下的每个topic进行rebalance
DefaultMQPushConsumer.RebalanceImpl-> DefaultMQPushConsumer.RebalanceImpl:从主题订阅缓存表中取出主题的队列信息mqSet \n topicSubscribeInfoTable.get(topic)
DefaultMQPushConsumer.RebalanceImpl-> DefaultMQPushConsumer.RebalanceImpl:从broker获取所有消费者cidAll
DefaultMQPushConsumer.RebalanceImpl-> DefaultMQPushConsumer.RebalanceImpl:对两者排序，以"平均分配"策略，给本机分配队列allocateResult
DefaultMQPushConsumer.RebalanceImpl-> DefaultMQPushConsumer.RebalanceImpl:对新分配队列集合和老分配队列集合进行对比
DefaultMQPushConsumer.RebalanceImpl-> DefaultMQPushConsumer.RebalanceImpl:对于不在新队列集合的老队列 1.设置drop=true \n 2.持久化offset到broker \n 3.将MessageQueue，ProcessQueue从缓存表中移除

DefaultMQPushConsumer.RebalanceImpl-> DefaultMQPushConsumer.RebalanceImpl:对于本次新增加队列：1.从broker获取offset \n 2.封装PullRequest
DefaultMQPushConsumer.RebalanceImpl-> PullMessageService:PullRequest加入PullMessageService中pullRequestQueue，唤醒PullMessageService线程
DefaultMQPushConsumer.RebalanceImpl-> DefaultMQPushConsumer.RebalanceImpl:发心跳给broker通知broker自己分配的队列信息

PullMessageService -> PullMessageService:pullRequestQueue.take 取出PullRequest进行消费
PullMessageService -> PullMessageService:根据PullRequest中的group调用对应的DefaultMQPushConsumer.pullMessage

PullMessageService -> DefaultMQPushConsumerImpl:获取PullRequest的ProcessQueue，判断是否drop

DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:1.获取ProcessQueue总消息数cachedMessageCount \n 2.获取processQueue最大偏移量和最小偏移量间距cachedMessageSizeInMiB
DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:如果cachedMessageCount>1000 进行流量控制，延迟处理PullRequest
DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:如果cachedMessageSizeInMiB>100 进行流量控制，延迟处理PullRequest
DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:如果拉取该主题订阅信息为空，延迟处理PullRequest
DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:设置sysFlag，标记是否支持长轮。。。
DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:设置PullCallback，从 Broker 拉取到消息后的回调方法
DefaultMQPushConsumerImpl -> broker:pullAPIWrapper.pullKernelImpl 从broker拉取消息
broker-> DefaultMQPushConsumerImpl:返回拉取消息，执行PullCallback

activate DefaultMQPushConsumerImpl
DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:FOUND-从PullResult中获取nextOffset，记录到Pullrequest，方便下次拉取
DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:FOUND-将拉取的消息MsgFoundList，放入ProcessQueue
DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:封装ConsumeRequest，放入consumeMessageService异步消息处理
DefaultMQPushConsumerImpl -> DefaultMQPushConsumerImpl:立即将PullRequest放回PullrequestQueue，保证后面执行消息获取
DefaultMQPushConsumerImpl --> ConsumeRequest
deactivate

ConsumeRequest -> ConsumeRequest:判断processQueue是否drop
ConsumeRequest -> ConsumeRequest:获取messageListener，业务处理函数
ConsumeRequest -> ConsumeRequest:恢复重试消息主题名
ConsumeRequest -> ConsumeRequest:***执行业务回调函数***
ConsumeRequest -> ConsumeRequest:根据业务函数返回结果，处理返回结果
ConsumeRequest -> ConsumeRequest:消费失败的消息，需要ACK，通知broker延迟发送
ConsumeRequest -> ConsumeRequest:如果ACK失败，将这批消息封装为 ConsumeRequest放在本地，然后延迟 5s 后 重新消费
ConsumeRequest -> ConsumeRequest:将已经消费的消息从ProcessQueue中移除后，然后再获取最小偏移量offset
ConsumeRequest -> ConsumeRequest:记录消费之后的偏移量offset放入本地，然后等待定时任务再次将offset同步到broker中




@enduml